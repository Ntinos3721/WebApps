using Microsoft.VisualBasic;using System;using System.Collections;using System.Collections.Generic;using System.Data;using System.Diagnostics;using System.Linq;using System.Text;using System.Threading.Tasks;using System.IO;using System.Net;using System.Text.RegularExpressions;namespace IOUtils{    public class IOUtils    {        private static Object thisLock = new Object();        public static void WriteToFile(string text, string outputFilePath = "", bool append = true)        {            lock (thisLock)            {                if (string.IsNullOrEmpty(outputFilePath))                {                    //outputFilePath = My.Application.Info.DirectoryPath + "\\log.txt";                    outputFilePath = AppDomain.CurrentDomain.BaseDirectory + "\\log.txt";                }                if (outputFilePath.IndexOf("\\") > -1)                {                    string OutputPath = outputFilePath.Substring(0, outputFilePath.LastIndexOf("\\"));                    if (!System.IO.Directory.Exists(OutputPath))                    {                        System.IO.Directory.CreateDirectory(OutputPath);                    }                }                if (!append)                {                    if (System.IO.File.Exists(outputFilePath))                    {                        System.IO.File.Delete(outputFilePath);                    }                }                System.IO.StreamWriter objWriter = new System.IO.StreamWriter(outputFilePath, append, System.Text.Encoding.GetEncoding("ISO-8859-7"));                //Dim conv As New CConv.CharacterSetConvertion                Exception exc = null;                try                {                    //text = text.ToUpper()                    byte[] bv = new byte[text.Length];                    System.Text.Encoding.GetEncoding("ISO-8859-7").GetBytes(text, 0, text.Length, bv, 0);                    text = System.Text.Encoding.GetEncoding("ISO-8859-7").GetString(bv);                    //text = conv.Convert(CConv.CharacterSetConvertion.CharacterSet.ELOT928, CConv.CharacterSetConvertion.CharacterSet.U100, text)                    objWriter.WriteLine(text);                }                catch (Exception ex)                {                    exc = ex;                }                finally                {                    if (objWriter != null)                    {                        objWriter.Close();                    }                }                if (exc != null)                {                    throw exc;                }            }        }        /// <summary>        /// Deletes all files within a given directory.        /// </summary>        /// <param name="Path">The directory whose contained files will be deleted.</param>        /// <param name="Pattern">Optional parameter which specifies the pattern by which the directory will be scanned. Default is *.*</param>        /// <remarks></remarks>        public static void DeleteFiles(string Path, string Pattern = "*.*")        {            bool blnRet = false;            List<string> lstFiles = GetDirectoryFiles(Path, Pattern);            foreach (string strFile in lstFiles)            {                File.SetAttributes(strFile, FileAttributes.Normal);                File.Delete(strFile);            }        }        /// <summary>        /// Returns a list of strings, with all the files within a directory.        /// </summary>        /// <param name="Path">The directory whose contained files will be returned.</param>        /// <returns>List of strings</returns>        /// <remarks></remarks>        public static List<string> GetDirectoryFiles(string Path)        {            return GetDirectoryFiles(Path, "*.*", string.Empty);        }        /// <summary>        /// Returns a list of strings, with all the files within a directory based on a search pattern.        /// </summary>        /// <param name="Path">The directory whose contained files will be returned.</param>        /// <param name="SearchPattern">Specifies the pattern by which the directory will be scanned.</param>        /// <returns>List of strings</returns>        /// <remarks></remarks>        public static List<string> GetDirectoryFiles(string Path, string SearchPattern)        {            return GetDirectoryFiles(Path, SearchPattern, string.Empty);        }        /// <summary>        /// Returns a list of strings, with all the files within a directory based on a search pattern, excluding files matched by ExcludePattern.        /// </summary>        /// <param name="Path">The directory whose contained files will be returned.</param>        /// <param name="SearchPattern">Specifies the pattern by which the directory will be scanned.</param>        /// <param name="ExcludePattern">Specifies the pattern by which files within the directory will be excluded.</param>        /// <returns>List of strings</returns>        /// <remarks></remarks>        public static List<string> GetDirectoryFiles(string Path, string SearchPattern, string ExcludePattern)        {            // This list stores the results.            List<string> lstResult = new List<string>();            List<string> lstNewResult = new List<string>();            // This stack stores the directories to process.            Stack<string> stack = new Stack<string>();            if (Path.Substring(Path.Length - 1, 1) != "\\")            {                Path += "\\";            }            // Add the initial directory            stack.Push(Path);            // Continue processing for each stacked directory            while ((stack.Count > 0))            {                // Get top directory string                string dir = stack.Pop();                try                {                    // Add all immediate file paths                    lstResult.AddRange(Directory.GetFiles(dir, SearchPattern));                    // Loop through all subdirectories and add them to the stack.                    foreach (string directoryName in Directory.GetDirectories(dir))                    {                        stack.Push(directoryName);                    }                }                catch (Exception ex)                {                }            }            if (!object.ReferenceEquals(ExcludePattern, string.Empty))            {                string strFileName = string.Empty;                foreach (string item in lstResult)                {                    strFileName = item.Substring(item.LastIndexOf('\\') + 1);                    if (!Regex.IsMatch(strFileName, ExcludePattern, RegexOptions.Multiline))                    {                        lstNewResult.Add(item);                    }                }            }            else            {                lstNewResult = lstResult;            }            return lstNewResult;        }    }}
